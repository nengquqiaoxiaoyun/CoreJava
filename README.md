# CoreJava
​	Java 核心技术卷一 (第十版)

## 第三章

### 3.3 数据类型

#### 3.3.1 整型

​	*0x*前缀表示*16*进制，*0b*前缀表示*2*进制，*0*前缀表示*8*进制，*8*进制表示法比较容易混淆。

#### 3.3.3 *char*类型

​	*\u*是一个转义序列，可以出现在**加引号的字符字面量或字符串**中。*\u*后面跟着四个*16*进制数来表示一个*Unicode*字符。

### 3.5.2 数值类型之间的转换

​	两个不同类型的数值进行二元操作时，先要将两个操作数转换为同一种类型，然后再进行计算。

- 有*double*转成*double*
- 否则，有*float*转成*float*
- 否则，有*long*转为*long*
- **否则两个操作数都会被转为*int***

#### 3.5.3 强制类型转换

​	**强制类型转换可能会导致信息丢失。**只有极少数的情况下才需要将布尔类型转换为数值类型，这时可以使用条件表达式 *b ? 1 : 0*;

#### 3.5.4 结合赋值和运算符

​	可以在赋值中使用二元运算符，如： *x += 4;* 等价于 *x = x + 4;* **如果运算符得到的一个值，其类型与左侧操作数的类型不同，就会发生强制类型转换。如果*x*是*int*，则 *x += 3.5* 是合法的，将把*x*设置为 *(int)(x + 3.5);***

#### 3.5.5 自增与自减运算符

```java
// 后缀形式
i++;
// 前缀形式
++i;
在表达式中，两者存在区别。前缀形式会先完成 + 1, 后缀形式会使用变量原来的值。
int m = 7;
int n = 7;
// a = 16, m = 8
int a = 2 * ++m;
// b = 14, n = 8
int b = 2 * n++;
```

#### 3.5.6 关系和*boolean*运算符

​	使用*&&*和*||*表示与运算和或运算，它们是按照*”短路“*方式来求值的：**如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。**对于与运算来说，第一个为*false(0)*则不必再进行计算，对于或运算第一个为*true(1)*则不必再进行计算。

### 3.6.3 不可变字符串

​	由于不能修改*Java*字符串中的字符，所以在Java文档中将*String*类对象称为*不可变字符串*。**不可变字符串使得编译器可以让字符串共享。**

### 3.8.4 确定循环

​	一般情况下，如果从*n*个数字中抽取*k*个数字，就可以使用下列公式得到结果

​			**( n * (n - 1) * (n - 2) * … * (n - k + 1)  ) / 1 * 2 * 3 * … * k** 

下面的for循环语句计算了上面这个公式的值

```java
int lottery = 1;
for (int i = 1; i <= k; i++) {
    lottery = lottery * (n - i + 1) / i;
}
```

#### 3.8.6 中断控制流程语句

​	*Java*提供一种带标签的*break*语句，用于跳出多重嵌套的循环语句。**标签必须放在希望跳出的最外层循环之前， 并且必须紧跟一个冒号。**

```java
read_data:
while() {
    for() {
        if() {
            break read_data;
        }
    }
}
```

​	*continue*与*break*语句一样，它将中断正常的控制流程。***continue*语句将控制转移到最内层循环的首部。**

```java
for() {
    if(n < 0) {
        continue;
    }
    // n < 0的话就不执行
    sum += n;
}
```

​	还有一种带标签的*continut*语句，将跳到与标签匹配的循环内部。

### 3.9 大数值

​	如果基本的整数和浮点精度不能够满足需求，那么可以使用*java.math*包中的两个类：*BIgInteger*和*BigDecimal*。这两个类可以处理包含任意长度数字序列的数值。

​	不能使用算术运算符处理大数值，而需要使用大数值类中的方法如*add*，*subtract*方法等来进行算术。

​	**为了防止精度损失，静止使用构造方法*BigDecimal(double)*的方式把*double*值转为*BigDecimal*对象。**

### 3.10 数组

​	**创建一个数字数组时，所有的元素都初始化为*0*。*boolean*数组的元素会初始化为*false*。对象数组的元素则初始化为一个特殊值*null*，这表示这些元素（还）未存放任何对象。**

##### 3.10.3 数组拷贝

​	如果希望将一个数组的所有值拷贝到一个新的数组中去，就要使用*Arrays*类的*copyOf*方法。这个方法通常用来增加数组的大小。

## 第四章 对象与类

### 4.1 面向对象程序设计概述

​	**面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。**<u>从根本上说，只要对象能够满足要求，就不必关心其功能的具体实现过程。在*OOP*中，不必关心对象的具体实现，只要能够满足用户的需求即可。</u>**在*OOP*中，数据是第一位的，然后再考虑操作数据的算法。**（先考虑数据结构，其次是算法）

### 4.2.2  *Java*类库中的*LocalDate*类

- *LocalDate*只提供日期不提供时间信息，它是不可变类且线程安全的
- *LocalTime*只提供时间而不提供日期信息，它是不可变类且线程安全的
- *LocalDateTime*提供时间和日期的信息，它是不可变类且线程安全的

### 4.3.4 从构造器开始

- 构造器与类同名
- 每个类可以有一个以上的构造器
- 构造器可以有*0*个、*1*个或多个参数
- 构造器没有返回值
- 构造器总是伴随着*new*操作一起调用

#### 4.3.6 封装的优点

​	注意不要编写返回引用可变对象的访问器方法。

```java
class Employee {
    private Date hireDay;
    
    public Date getHireDay() {
        // bad
        return hireDay;
    }
}
```

​	该类违反了这个设计原则，其中的*getHireDay*返回了一个*Date*类对象。*LocalDate*类没有更改器方法，与之不同，*Date*类有一个更改器方法*setTime*，可以在这里设置毫秒值。***Date*对象是可变的，这一点就破坏了封装性！**

```java
Employee harry =  ...;
Date d = harr.getHireDay();
double tenYearsInMilliSeconds = 10 * 365.25 * 24 * 60 * 60 * 1000;
d.setTime(d.getTime() - (long) tenYearsInMilliSeconds);
```

​	***d*和*harry.hireDay*将引用同一个对象。对*d*调用更改器方法就可以自动地改变这个雇员对象的私有状态！（该雇员的*hireDay*也会随着d的改变而改变）**

​	**如果需要返回一个可变对象，应该首先对它进行克隆。**

```java
class Employee {
    public Date getHireDay() {
        return (Date) hireDay.clone();
    }
}
```

#### 4.3.7 基于类的访问权限

​	**一个方法可以访问所属类的所有对象的私有数据。**

#### 4.3.9 *final* 实例域

​	被*final*修饰的实例域（属性）必须被初始化（直接赋值或构造器中赋值）。也就是说，必须确保在每一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改。因为在对象构建之后，这个值不会再被修改，即没有*set*方法。

​	**对于基本类型，*final*使数值恒定不变；对于引用类型，*final*使引用恒定不变。**一旦引用被初始化指向一个对象，就无法再把它改为指向另一个对象。然而，对象其自身确是可以被修改的。

### 4.4 静态域与静态方法

##### 4.4.1 静态域

​	静态域被称为类域，**它属于类而不属于任何独立的对象。一个类的所有实例将共享同一个静态域。**

##### 4.4.3 静态方法

​	**静态方法没有隐式的参数。**可以认为静态方法是没有this参数的方法（在一个非静态方法中，this参数表示这个方法的隐式参数）

​	在下面两种情况下使用静态方法：

- 一个方法不需要访问对象状态，其所需参数都是通过显示参数提供
- 一个方法只需要访问类的静态域

##### 4.4.4 工厂方法

​	静态方法还有另外一种常见的用途，使用静态工厂方法来构造对象。使用静态工厂方法来构造对象有如下好处：

- 可以命名。**构造器无法命名，构造器的名字必须与类名相同。**使用静态工厂方法可以任意命名
- 可以返回其他类型。**当使用构造器时，无法改变所构造的对象类型。**而静态工厂方法可以返回其他类对象（多态）

##### 4.4.5 *main*方法

​	***main*方法不对任何对象进行操作。事实上，在启动程序时还没有任何一个对象。**静态的*main*方法将执行并创建程序所需要的对象。

### 4.5 方法参数

​	如果一个形参是值参*（call by value）*，调用单元将把实参的一个副本传递给子程序。如果一个形参是引用参数（*call by reference）*，调用单元将把实参的地址传递给子程序。Java程序设计语言总是采用按值调用。也就是说，**方法得到的是所有参数值得一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。**

```java
double percent = 10;
harry.raiseSalary(percent);
```

不必理睬*raiseSalary*的具体实现，方法调用过后，*percent*的值还是*10*

​	**对象引用作为参数也会进行拷贝，拷贝的是一个对象的引用。拷贝后的引用和原引用指向的是同一个对象。**

​	总结一下*Java*中**方法参数**的使用情况：

- 一个**方法**不能修改一个基本数据类型的参数（原值不会被修改）
- 一个**方法**可以改变一个对象参数的状态
- 一个**方法**不能让对象参数引用一个新的对象（原引用不会被修改）

### 4.6 对象构造

##### 4.6.1 重载

​	**如果多个方法有相同的名字，不同的参数变产生了重载。方法的返回类型不是方法签名的一部分。**也就是说，不能有两个名字相同，参数相同而返回值类型不同的方法。

##### 4.6.2 默认域初始化

​	如果在构造器中没有显示地给域赋予初始值，那么就会被自动地赋为默认值：数值为*0*、布尔值为*false*、对象引用为*null*。**这是域与局部变量的主要区别。局部变量必须明确地在方法中初始化！但是，如果没有初始化类中的域，将会被自动初始化为默认值。**

##### 4.6.6 调用另一个构造器

​	如果构造器的**第一个语句形如*this(…)***，这个构造器将调用同一个类的另一个构造器。

```java
public Employee(double s) {
    // calls Employee(String, Double)
    this("Employee #" + nextId, s);
    nextId++;
}
```

##### 4.6.7 初始化块

###### 非静态初始化块

​	**基本跟构造函数一个功能，但比构造函数先执行。**最常见的用法应该还是**代码复用**，即多个重载构造函数都有若干段相同的代码，那么可以把这些重复的代码拉出来放到初始化块中，但仍然要注意它的执行顺序，对顺序有严格要求的初始化代码就不适合使用了。

​	下面是调用构造器的具体处理步骤：

1. 所有数据域被初始化为默认值
2. 按照在类中申明中出现的次序，**依次执行所有域初始化语句和初始化块**
3. 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体
4. 执行这个构造器的主体

总结：

1. 静态初始化块的优先级最高，最先执行，**仅在类第一次加载时被执行（仅执行依次）**
2. 非静态初始化块和构造函数后执行，并且在每次生成对象时执行一次
3. 静态初始化块既可以用于初始化静态域，也可以执行初始化代码
4. 非静态初始化块可以针对多个重载构造函数进行代码复用

### 4.7.1 类的导入

​	如果需要导入两个不同包下的同名类，需要在每个类名前面加上完整的包名。

#### 4.7.4 包作用域

​	可以通过包密封机制来解决将各种包混杂在一起的问题。如果将一个包密封起来，就不能再向这个包添加类。

### 4.10 类设计技巧

1. 保证数据私有

2. 一定要对数据初始化

   ​	定义*POJO*类，不要设定任何的默认属性值。

3. 不要类中使用过多的基本类型

   ​	用其他的类来代替相关的基本类型

4. 不是所有的域都需要独立的域访问器和域更改器

5. 命名要有意义

6. 优先使用不可变类